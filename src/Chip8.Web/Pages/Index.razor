@page "/"
@using Aptacode.BlazorCanvas
@using Chip8
@using Chip8.Model
@using Chip8.Model.IO;
@using Chip8.Web.IO
@using System.Threading.Tasks.Dataflow
@using Chip8.Web.Model;
@using System.Text;
@inject IJSRuntime JsRuntime
@inject HttpClient http

<PageTitle>CHIP-8 emulator on Blazor Web Assembly</PageTitle>
<h1>Chip-8</h1>
<h2>on Blazor WebAssembly</h2>

<header>
    <a href="https://github.com/Moreno-Gentili/Chip8" target="_blank" rel="noopener" class="github-link" style="text-decoration: none;"><p class="nes-balloon is-dark from-right">Fork me<br>on GitHub</p> <i class="nes-octocat"></i></a>
</header>

<main>
    <header id="selector">
        <InputFile @ref="fileSelector" OnChange="LoadRomFromDisk" class="btn-primary" hidden />
        <div class="nes-select is-dark">
            <select @onchange="LoadRom">
                <option value="-">Load from disk...</option>
                @if (diskRomPath is not null)
                {
                    <option value="." selected>@diskRomPath</option>
                }
                @foreach (var romGroup in roms.GroupBy(r => r.Group))
                {
                    <optgroup label="@romGroup.Key">
                        @foreach (var rom in romGroup)
                        {
                            <option value="@rom.Crc32" selected="@(rom.Crc32 == defaultSelectedRom)">@GetRomFullName(rom)</option>
                        }
                    </optgroup>
                }
            </select>
        </div>
        <button type="button" class="nes-btn is-error" @onclick="Reset">Reset</button>
    </header>
    <section id="emulator">
        <article id="display">
            <div id="lcd">
                <BlazorCanvas @ref="canvas">
                    <canvas width="@canvasWidth" height="@canvasHeight" hidden="@(displayType != DisplayType.Lcd)"></canvas>
                </BlazorCanvas>
            </div>
            <div id="crt" hidden="@(displayType != DisplayType.Crt)"></div>
        </article>

        @if (keyboard is not null)
        {
            <aside id="keyboard">
                @foreach (var entry in keyboard.Keys)
                {
                    <button type="button" data-key="@entry.Key" class="@GetKeyboardButtonClassName(entry.Value)" @onmousedown="() => keyboard.HandleKeyDown(entry.Value)" @onmouseup="() => keyboard.HandleKeyUp(entry.Value)">@entry.Key<span class="alt-key" data-key="@GetKeyboardAltKey(entry.Value)">@GetKeyboardAltKey(entry.Value)</span></button>
                }
            </aside>
        }
    </section>

    <nav id="options">
        <span id="display-option">
        <img src="/images/display.png" alt="Display" />
        <label>
            <input type="radio" class="nes-radio is-dark" name="answer-dark" checked value="@nameof(DisplayType.Crt)" @onchange="SetDisplay" />
            <span>@nameof(DisplayType.Crt)</span>
        </label>
        </span>

        
        <label>
            <input type="radio" class="nes-radio is-dark" name="answer-dark" value="@nameof(DisplayType.Lcd)" @onchange="SetDisplay" />
            <span>@nameof(DisplayType.Lcd)</span>
        </label>

        <span id="audio-option">
        <img src="/images/audio.png" alt="Audio" />
        <button @onclick="ToggleAudio">@audioText</button>
        </span>

        <span id="fullscreen-option">
        <img src="/images/fullscreen.png" alt="Audio" />
        </span>
    </nav>
</main>

@if (state is not null && cassette is not null && cassette.Crc32 is not null)
{
    <footer id="debug">
        <details>
            <summary>Debug</summary>

            <dl>
                <dt title="ROM checksum (CRC32)">CRC32</dt>
                <dd>@cassette.Crc32</dd>
                <dt title="Frames per second">FPS</dt>
                <dd>@Convert.ToInt32(Math.Round(fps.Average()))</dd>
                <dt title="Instructions per second">IPS</dt>
                <dd>@vm?.CpuInstructionsPerSecond</dd>
                <dt title="Opcode (16 bit)">OPCODE</dt>
                <dd id="opcode">@state["OPCODE"]</dd>
                <dt title="Program Counter (16 bit)">PC</dt>
                <dd>@state["PC"]</dd>
                <dt title="Register I (16 bit)">I</dt>
                <dd>@state["I"]</dd>
                <dt title="Sound Timer (8 bit)">ST</dt>
                <dd>@state["ST"]</dd>
                <dt title="Delay Timer (8 bit)">DT</dt>
                <dd>@state["DT"]</dd>
                <dt title="Stack Pointer (8 bit)">SP</dt>
                <dd>@state["SP"]</dd>
                <dt title="Stack (16 * 16 bit)">STACK</dt>
                <dd id="stack">@state["STACK"]</dd>
            </dl>

            <dl>
                <dt title="Register V0 (8 bit)">V0</dt>
                <dd>@state["V0"]</dd>
                <dt title="Register V1 (8 bit)">V1</dt>
                <dd>@state["V1"]</dd>
                <dt title="Register V2 (8 bit)">V2</dt>
                <dd>@state["V2"]</dd>
                <dt title="Register V3 (8 bit)">V3</dt>
                <dd>@state["V3"]</dd>
                <dt title="Register V4 (8 bit)">V4</dt>
                <dd>@state["V4"]</dd>
                <dt title="Register V5 (8 bit)">V5</dt>
                <dd>@state["V5"]</dd>
                <dt title="Register V6 (8 bit)">V6</dt>
                <dd>@state["V6"]</dd>
                <dt title="Register V7 (8 bit)">V7</dt>
                <dd>@state["V7"]</dd>
                <dt title="Register V8 (8 bit)">V8</dt>
                <dd>@state["V8"]</dd>
                <dt title="Register V9 (8 bit)">V9</dt>
                <dd>@state["V9"]</dd>
                <dt title="Register VA (8 bit)">VA</dt>
                <dd>@state["VA"]</dd>
                <dt title="Register VB (8 bit)">VB</dt>
                <dd>@state["VB"]</dd>
                <dt title="Register VC (8 bit)">VC</dt>
                <dd>@state["VC"]</dd>
                <dt title="Register VD (8 bit)">VD</dt>
                <dd>@state["VD"]</dd>
                <dt title="Register VE (8 bit)">VE</dt>
                <dd>@state["VE"]</dd>
                <dt title="Register VF (8 bit)">VF</dt>
                <dd>@state["VF"]</dd>
            </dl>
            <nav id="debug-toolbar">
                <button type="button" id="debug-pause" accesskey="P" title="Toggle pause (ALT+P)" class="@GetTogglePauseClassName()" @onclick="TogglePause"><img src="/images/pause.png" /></button>
                <button type="button" id="debug-step" accesskey="O" title="Step over (ALT+O)" class="@GetStepOverClassName()" @onclick="Step" disabled="@(shouldStep is null)"><img src="/images/step.png" /></button>
            </nav>
        </details>
    </footer>
}

<dialog @ref="errorDialog" class="nes-dialog is-dark is-rounded">
    <form method="dialog">
        <p class="title">Error</p>
        <p>@errorText</p>
        <menu class="dialog-menu">
            <button class="nes-btn is-success">Close</button>
        </menu>
    </form>
</dialog>

@code {
    const int canvasWidth = 640;
    const int canvasHeight = 320;
    BlazorCanvas? canvas;
    InputFile? fileSelector;
    ElementReference? errorDialog;
    Dictionary<char, Key>? additionalKeyMap;
    Dictionary<Key, char>? reverseAdditionalKeyMap;
    bool? shouldStep = null;
    string? diskRomPath = null;
    List<float> fps = new();
    float lastUpdate = 0;
    string? defaultSelectedRom;

    Rom[] roms = new Rom[0];

    IVirtualMachine? vm;
    Cassette? cassette;
    Speaker? speaker;
    Display? display;
    Keyboard? keyboard;
    DisplayType displayType = DisplayType.Crt;
    bool hasAudio = false;
    string audioText = "Unmute";
    TimeSpan lastTimestamp = TimeSpan.Zero;
    bool faulted = false;
    string errorText = string.Empty;

    Dictionary<string, string?>? state = null;

    private async void ToggleAudio()
    {
        hasAudio = !hasAudio;
        audioText = hasAudio ? "Mute" : "Unmute";
        await JsRuntime.InvokeVoidAsync("toggleAudio", hasAudio);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
            return;

        if (canvas is null)
        {
            await ShowError("Canvas is not inizialized");
            return;
        }

        roms = await GetRoms();

        cassette = new();
        speaker = new(new ActionBlock<bool>(SetBuzzer));
        keyboard = new();
        display = new(canvas, canvasWidth, canvasHeight);
        display.Connect(displayType);

        await JsRuntime.InvokeAsync<object>("initEmulator", DotNetObjectReference.Create(this));
        await Reset();
        await LoadDefaultRom();
        await FocusPage();
    }

    [JSInvokable]
    public async void Update(float timeStamp)
    {
        if (canvas?.Ready != true || vm is null || faulted)
        {
            return;
        }

        UpdateFps(timeStamp);

        try
        {
            TimeSpan? time = GetTime(timeStamp, shouldStep, lastTimestamp, vm.CpuInstructionsPerSecond);
            if (time is null)
            {
                return;
            }

            lastTimestamp = time.Value;
            vm.Update(time.Value);
            state = vm.GetState();

            if (shouldStep == true)
            {
                shouldStep = false;
            }

            StateHasChanged();
        }
        catch (Exception)
        {
            faulted = true;
            await ShowError("Runtime error: ROM is not valid");
        }
    }

    private static TimeSpan? GetTime(float timeStamp, bool? shouldStep, TimeSpan lastTimestamp, int cpuInstructionsPerSecond)
    {
        return shouldStep switch
        {
            null => TimeSpan.FromMilliseconds(timeStamp),
            true => lastTimestamp + TimeSpan.FromSeconds(1) / cpuInstructionsPerSecond,
            false => (TimeSpan?)null,
        };
    }

    private void UpdateFps(float timeStamp)
    {
        if (lastUpdate == 0)
        {
            lastUpdate = timeStamp;
            return;
        }

        fps.Add(1000 / (timeStamp - lastUpdate));
        if (fps.Count > 10)
        {
            fps.RemoveAt(0);
        }

        lastUpdate = timeStamp;
    }

    [JSInvokable]
    public void HandleKeyDown(string key)
    {
        keyboard?.HandleKeyDown(key[0], additionalKeyMap);
    }

    [JSInvokable]
    public void HandleKeyUp(string key)
    {
        keyboard?.HandleKeyUp(key[0], additionalKeyMap);
    }

    private async Task FocusPage()
    {
        await JsRuntime.InvokeVoidAsync("focusMainButton");
    }

    private async Task Reset()
    {
        if (cassette is null || keyboard is null || display is null || speaker is null)
        {
            await ShowError("IO devices not initialized");
            return;
        }

        try
        {
            vm = VirtualMachine.Create(cassette, keyboard, display, speaker);
            await SetBuzzer(false);
            faulted = false;
            await JsRuntime.InvokeVoidAsync("clearCanvas");
        }
        catch
        {
            faulted = true;
            await ShowError("Loading error: this is not a valid ROM");
        }
    }

    private async Task<Rom[]> GetRoms()
    {
        try
        {
            KnownRoms knownRoms = await http.GetFromJsonAsync<KnownRoms>("data/known-roms.json") ?? throw new InvalidOperationException("Invalid rom data");
            defaultSelectedRom = knownRoms.Selected;
            return knownRoms.Roms;
        }
        catch (Exception exc)
        {
            await ShowError(exc.Message);
            return new Rom[0];
        }
    }

    private async Task LoadDefaultRom()
    {
        if (defaultSelectedRom is null)
        {
            return;
        }

        Rom? defaultRom = roms.FirstOrDefault(r => r.Crc32 == defaultSelectedRom);
        if (defaultRom is not null)
        {
            await LoadRomFromHttp(defaultRom);
        }
    }

    private async Task LoadRomFromHttp(Rom rom)
    {
        if (cassette is null)
        {
            await ShowError("Cassette is not ready");
            return;
        }

        try
        {
            await cassette.Change(rom.Url);
            await Reset();
            SetIps(rom.Ips);
            SetKeyMap(rom);
        }
        catch (Exception exc)
        {
            await ShowError($"Loading error: {exc.Message}");
        }
    }

    private async void LoadRomFromDisk(InputFileChangeEventArgs e)
    {
        if (cassette is null)
        {
            await ShowError("Cassette is not ready");
            return;
        }

        try
        {
            await cassette.Change(e.File.OpenReadStream());
            await Reset();
            SetIps(null);
            diskRomPath = e.File.Name;
            additionalKeyMap = null;
            reverseAdditionalKeyMap = null;
        }
        catch (Exception exc)
        {
            await ShowError($"Loading error: {exc.Message}");
        }
    }

    private async void LoadRom(ChangeEventArgs args)
    {
        diskRomPath = null;
        Rom? rom = roms.SingleOrDefault(r => r.Crc32 == args.Value?.ToString());
        if (rom is not null)
        {
            await LoadRomFromHttp(rom);
        }
        else
        {
            await PromptFileSelection();
        }
    }

    private async Task PromptFileSelection()
    {
        await JsRuntime.InvokeVoidAsync("promptFileSelection", fileSelector?.Element);
    }

    private void SetIps(int? ips)
    {
        if (vm is null)
        {
            return;
        }

        if (ips is null)
        {
            vm.ResetCpuInstructionsPerSecond();
        }
        else
        {
            vm.CpuInstructionsPerSecond = ips.Value;
        }
    }

    private void SetKeyMap(Rom rom)
    {
        additionalKeyMap = rom.GetKeyMap();
        reverseAdditionalKeyMap = additionalKeyMap?.ToDictionary(entry => entry.Value, entry => entry.Key);
    }


    private void SetDisplay(ChangeEventArgs args)
    {
        if (display is null)
        {
            throw new InvalidOperationException("Display is not ready");
        }

        displayType = Enum.Parse<DisplayType>(args.Value?.ToString() ?? string.Empty);
        display.Connect(displayType);
    }

    private async Task SetBuzzer(bool on)
    {
        await JsRuntime.InvokeVoidAsync(on ? "playAudio" : "stopAudio");
    }

    private async Task ShowError(string text)
    {
        errorText = text;
        await JsRuntime.InvokeVoidAsync("showError", errorDialog);
    }

    private string GetKeyboardButtonClassName(Key key)
    {
        if (reverseAdditionalKeyMap is null || reverseAdditionalKeyMap.ContainsKey(key))
        {
            return "nes-btn";
        }
        else
        {
            return "nes-btn is-disabled";
        }
    }

    private string GetKeyboardAltKey(Key key)
    {
        if (reverseAdditionalKeyMap?.TryGetValue(key, out char value) == true)
        {
            return value.ToString();
        }

        return string.Empty;
    }

    private string GetStepOverClassName()
    {
        return $"nes-btn {(shouldStep is null ? "is-disabled" : "")}";
    }

    private string GetTogglePauseClassName()
    {
        return $"nes-btn {(shouldStep is null ? "" : "is-success")}";
    }

    private void TogglePause()
    {
        if (shouldStep is null)
        {
            shouldStep = false;
        }
        else if (vm is not null)
        {
            shouldStep = null;
            vm.ResetClock();
        }
    }

    private void Step()
    {
        shouldStep = true;
    }

    private static string GetRomFullName(Rom rom)
    {
        StringBuilder name = new();
        name.Append(rom.Name);

        if (rom.Year is not null)
        {
            name.Append(" (");
            name.Append(rom.Year.ToString());
            name.Append(")");
        }

        if (rom.Author is not null)
        {
            name.Append(" by ");
            name.Append(rom.Author);
        }

        return name.ToString();
    }
}
