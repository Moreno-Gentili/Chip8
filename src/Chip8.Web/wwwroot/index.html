<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>CHIP-8 emulator on Blazor WebAssembly</title>
    <base href="/" />
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <link href="https://unpkg.com/nes.css@2.3.0/css/nes.min.css" rel="stylesheet" />
    <link href="css/app.css" rel="stylesheet" />
    <link rel="icon" type="image/png" href="/images/favicon.png" />
    <meta property="og:title" content="CHIP-8 emulator on Blazor WebAssembly" />
    <meta property="og:image" content="/images/preview.gif" />
</head>

<body>
    <div id="app">
        <svg id="loader-bars" viewBox="-0.5 -0.5 1 1" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%;">
            <line id="line" x1="0" y1="-10" x2="0" y2="10" stroke="rgba(255, 255, 255, 0.3)" stroke-width="100" />
        </svg>
        <script>
            let lineInterval;
            lineInterval = setInterval(function () {
                let lineInterval;
                const line = document.getElementById('line');
                if (!line) {
                    clearInterval(lineInterval);
                    return;
                }

                let dashes = [];
                for (i = 0; i < 100; i++) {
                    dashes.push((Math.random() * 0.04) + 0.01);
                }

                line.style.strokeDasharray = dashes.join(' ');
            }, 40);
        </script>
        <div id="loader">
            <div class="nes-text">PLEASE WAIT</div>
            <progress id="progressbar" class="nes-progress is-pattern is-dark" value="0" max="100" hidden></progress>
        </div>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">🗙</a>
    </div>
    <script>
        function update(timeStamp) {
            window.requestAnimationFrame(update);
            window.emulator.invokeMethodAsync('Update', timeStamp);
        }

        function normalizeKey(key) {
            key = key.toUpperCase();
            switch (key) {
                case "ARROWLEFT":
                    return "←";
                case "ARROWRIGHT":
                    return "→";
                case "ARROWUP":
                    return "↑";
                case "ARROWDOWN":
                    return "↓";
                case " ":
                    return "␣";
                case "1":
                case "2":
                case "3":
                case "4":
                case "Q":
                case "W":
                case "E":
                case "R":
                case "A":
                case "S":
                case "D":
                case "F":
                case "Z":
                case "X":
                case "C":
                case "V":
                    return key;
                default:
                    return null;
            }
        }

        function initEmulator(emulator) {
            window.emulator = emulator;

            window.addEventListener('keydown', evt => {
                const key = normalizeKey(evt.key);
                if (key !== null) {
                    evt.stopImmediatePropagation();
                    evt.preventDefault();
                    window.emulator.invokeMethodAsync('HandleKeyDown', key);
                }
            }, true);

            window.addEventListener('keyup', evt => {
                const key = normalizeKey(evt.key);
                if (key !== null) {
                    evt.stopImmediatePropagation();
                    evt.preventDefault();
                    window.emulator.invokeMethodAsync('HandleKeyUp', key);
                }
            }, true);

            window.requestAnimationFrame(update);
            renderCrt();
        }

        let audioContext;
        let audioOscillator;

        function enableAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            audioOscillator = audioContext.createOscillator();
            audioOscillator.type = 'sawtooth';
            audioOscillator.frequency.value = 700;
            audioOscillator.start();
        }

        function disableAudio() {
            audioContext = null;
            audioOscillator = null;
        }

        function playAudio() {
            if (audioOscillator) {
                audioOscillator.connect(audioContext.destination);
            }
        }

        function stopAudio() {
            if (audioOscillator) {
                audioOscillator.disconnect();
            }
        }

        function promptFileSelection(element) {
            if (element) {
                element.click();
            }
        }

        function focusMainButton() {
            const element = document.querySelector('button[data-key="W"]');
            if (element) {
                element.focus();
            }
        }

        function setFullscreen(element) {
            if (element) {
                element.requestFullscreen();
            }
        }

        document.body.addEventListener('dragover', function (evt) {
            evt.preventDefault();
            this.dataset.dragging = '1';
        }, true);

        document.body.addEventListener('dragend', function (evt) {
            evt.preventDefault();
            this.dataset.dragging = null;
        }, true);

        document.body.addEventListener('dragleave', function (evt) {
            evt.preventDefault();
            this.dataset.dragging = null;
        }, true);

        document.body.addEventListener('drop', function (evt) {
            evt.preventDefault();
            this.dataset.dragging = null;
            if (evt.dataTransfer.files && evt.dataTransfer.files.length > 0) {

                const file = evt.dataTransfer.files[0];
                const reader = new FileReader();
                reader.onload = function (e) {
                    const arrayBuffer = new Uint8Array(reader.result);
                    window.emulator.invokeMethodAsync('HandleFile', file.name, arrayBuffer);
                }

                reader.readAsArrayBuffer(file);
            }
            
        }, true);

        function showError(element) {
            if (element) {
                element.showModal();
            }
        }
    </script>

    <script src="_framework/blazor.webassembly.js" autostart="false"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.153.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.153.0/examples/jsm/"
          }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass';

        window.clearCanvas = function () {
            const canvas = document.querySelector('#lcd canvas');
            const ctx = canvas.getContext('2d');
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        };

        window.renderCrt = function () {

            const scene = new THREE.Scene();
            const renderer = new THREE.WebGLRenderer({ alpha: true });

            const canvas = document.querySelector('#lcd canvas');
            const geometry = new THREE.PlaneGeometry(2.3, 1);
            // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

            //const material = new THREE.MeshBasicMaterial();
            //material.map = new THREE.CanvasTexture(canvas);

            const canvasTexture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color(0, 255, 0),
                map: canvasTexture,
                transparent: true,
                emissiveIntensity: 0.0055,
                emissive: new THREE.Color(0, 255, 0),
                emissiveMap: canvasTexture
            });

            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            // Create camera
            // const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 1000000);
            camera.position.z = 1.5;

            // Create effect composer
            const composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            // Add distortion effect to effect composer
            var effect = new ShaderPass(getDistortionShaderDefinition());
            composer.addPass(effect);
            effect.renderToScreen = true;

            // Setup distortion effect
            var horizontalFOV = 85;
            var strength = 0.85;
            var cylindricalRatio = 0.9;
            var height = Math.tan(THREE.MathUtils.degToRad(horizontalFOV) / 2) / camera.aspect;

            camera.fov = Math.atan(height) * 2 * 180 / 3.1415926535;
            camera.zoom = 1.12;
            camera.updateProjectionMatrix();

            effect.uniforms["strength"].value = strength;
            effect.uniforms["height"].value = height;
            effect.uniforms["aspectRatio"].value = camera.aspect;
            effect.uniforms["cylindricalRatio"].value = cylindricalRatio;

            renderer.setSize(640, 320);
            document.getElementById('crt').appendChild(renderer.domElement);

            animate.bind(this, () => {
                material.map.needsUpdate = true;
                composer.render(scene, camera);
            })();
        }

        // https://stackoverflow.com/questions/13360625/three-js-fisheye-effect
        function getDistortionShaderDefinition() {
            return {

                uniforms: {
                    "tDiffuse": { type: "t", value: null },
                    "strength": { type: "f", value: 0 },
                    "height": { type: "f", value: 1 },
                    "aspectRatio": { type: "f", value: 1 },
                    "cylindricalRatio": { type: "f", value: 1 }
                },

                vertexShader: [
                    "uniform float strength;",          // s: 0 = perspective, 1 = stereographic
                    "uniform float height;",            // h: tan(verticalFOVInRadians / 2)
                    "uniform float aspectRatio;",       // a: screenWidth / screenHeight
                    "uniform float cylindricalRatio;",  // c: cylindrical distortion ratio. 1 = spherical

                    "varying vec3 vUV;",                // output to interpolate over screen
                    "varying vec2 vUVDot;",             // output to interpolate over screen

                    "void main() {",
                    "gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));",

                    "float scaledHeight = strength * height;",
                    "float cylAspectRatio = aspectRatio * cylindricalRatio;",
                    "float aspectDiagSq = aspectRatio * aspectRatio + 1.0;",
                    "float diagSq = scaledHeight * scaledHeight * aspectDiagSq;",
                    "vec2 signedUV = (2.0 * uv + vec2(-1.0, -1.0));",

                    "float z = 0.5 * sqrt(diagSq + 1.0) + 0.5;",
                    "float ny = (z - 1.0) / (cylAspectRatio * cylAspectRatio + 1.0);",

                    "vUVDot = sqrt(ny) * vec2(cylAspectRatio, 1.0) * signedUV;",
                    "vUV = vec3(0.5, 0.5, 1.0) * z + vec3(-0.5, -0.5, 0.0);",
                    "vUV.xy += uv;",
                    "}"
                ].join("\n"),

                fragmentShader: [
                    "uniform sampler2D tDiffuse;",      // sampler of rendered scene?s render target
                    "varying vec3 vUV;",                // interpolated vertex output data
                    "varying vec2 vUVDot;",             // interpolated vertex output data

                    "void main() {",
                    "vec3 uv = dot(vUVDot, vUVDot) * vec3(-0.5, -0.5, -1.0) + vUV;",
                    "gl_FragColor = texture2DProj(tDiffuse, uv);",
                    "}"
                ].join("\n")

            };
        }

        function animate(render) {
            requestAnimationFrame(animate.bind(this, render));
            render();
        }

    </script>
    <script>
        function StartBlazor() {
            let loadedCount = 0;
            const resourcesToLoad = [];
            Blazor.start({
                loadBootResource:
                    function (type, filename, defaultUri, integrity) {
                        if (type == "dotnetjs")
                            return defaultUri;

                        const fetchResources = fetch(defaultUri, {
                            cache: 'no-cache',
                            integrity: integrity
                        });

                        resourcesToLoad.push(fetchResources);

                        fetchResources.then((r) => {
                            loadedCount += 1;
                            if (filename == "blazor.boot.json")
                                return;
                            const totalCount = resourcesToLoad.length;
                            const percentLoaded = 10 + parseInt((loadedCount * 90.0) / totalCount);
                            const progressbar = document.getElementById('progressbar');
                            if (totalCount > 1) {
                                progressbar.hidden = false;
                            }
                            progressbar.value = percentLoaded;
                        });

                        return fetchResources;
                    }
            });
        }

        StartBlazor();
    </script>
</body>

</html>
