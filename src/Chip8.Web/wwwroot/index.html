<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Chip8.Web</title>
    <base href="/" />
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <link href="https://unpkg.com/nes.css@2.3.0/css/nes.min.css" rel="stylesheet" />
    <link href="css/app.css" rel="stylesheet" />
    <link rel="icon" type="image/png" href="favicon.png" />
</head>

<body>
    <div id="app">
        <span class="nes-text">Loading...</span>
        <progress id="progressbar" class="nes-progress is-pattern is-dark" value="0" max="100"></progress>
    </div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">ðŸ—™</a>
    </div>
    <script src="_framework/blazor.webassembly.js" autostart="false"></script>
    <script>
        function StartBlazor() {
            let loadedCount = 0;
            const resourcesToLoad = [];
            Blazor.start({
                loadBootResource:
                    function (type, filename, defaultUri, integrity) {
                        if (type == "dotnetjs")
                            return defaultUri;

                        const fetchResources = fetch(defaultUri, {
                            cache: 'no-cache',
                            integrity: integrity
                        });

                        resourcesToLoad.push(fetchResources);

                        fetchResources.then((r) => {
                            loadedCount += 1;
                            if (filename == "blazor.boot.json")
                                return;
                            const totalCount = resourcesToLoad.length;
                            const percentLoaded = 10 + parseInt((loadedCount * 90.0) / totalCount);
                            const progressbar = document.getElementById('progressbar');
                            progressbar.value = percentLoaded;
                        });

                        return fetchResources;
                    }
            });
        }

        StartBlazor();
    </script>

    <script src="_content/Blazor.Extensions.Canvas/blazor.extensions.canvas.js"></script>
    <script>
        function cycle(timeStamp) {
            window.requestAnimationFrame(cycle);
            window.emulator.invokeMethodAsync('Cycle', timeStamp);
        }

        function initEmulator(emulator) {
            window.emulator = emulator;

            window.addEventListener('keydown', ({ key }) => {
                window.emulator.invokeMethodAsync('HandleKeyDown', key.toLowerCase());
            });

            window.addEventListener('keyup', ({ key }) => {
                window.emulator.invokeMethodAsync('HandleKeyUp', key.toLowerCase());
            });

            window.requestAnimationFrame(cycle);
            renderCrt();
        }

        let audioContext;
        let audioOscillator;

        function toggleAudio(enabled) {
            if (enabled) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioOscillator = audioContext.createOscillator();
                audioOscillator.type = 'sawtooth';
                audioOscillator.frequency.value = 700;
                audioOscillator.start();
            } else {
                audioContext = null;
                audioOscillator = null;
            }
        }

        function playAudio() {
            if (audioOscillator) {
                audioOscillator.connect(audioContext.destination);
            }
        }

        function stopAudio() {
            if (audioOscillator) {
                audioOscillator.disconnect();
            }
        }
    </script>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.153.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.153.0/examples/jsm/"
          }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass';
        import { MaskPass } from 'three/addons/postprocessing/MaskPass';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass';
        import { CopyShader } from 'three/addons/shaders/CopyShader';

        window.renderCrt = function () {

            const scene = new THREE.Scene();
            const renderer = new THREE.WebGLRenderer();

            const canvas = document.getElementById('display');
            const geometry = new THREE.PlaneGeometry(2, 1);
            // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const material = new THREE.MeshBasicMaterial();
            material.map = new THREE.CanvasTexture(canvas);

            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            // Create camera
            // const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 1000000);
            camera.position.z = 1.5;

            // Create effect composer
            const composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            // Add distortion effect to effect composer
            var effect = new ShaderPass(getDistortionShaderDefinition());
            composer.addPass(effect);
            effect.renderToScreen = true;

            // Setup distortion effect
            var horizontalFOV = 80;
            var strength = 0.85;
            var cylindricalRatio = 0.7;
            var height = Math.tan(THREE.MathUtils.degToRad(horizontalFOV) / 2) / camera.aspect;

            camera.fov = Math.atan(height) * 2 * 180 / 3.1415926535;
            camera.zoom = 1.12;
            camera.updateProjectionMatrix();

            effect.uniforms["strength"].value = strength;
            effect.uniforms["height"].value = height;
            effect.uniforms["aspectRatio"].value = camera.aspect;
            effect.uniforms["cylindricalRatio"].value = cylindricalRatio;

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.border = "1px solid red";
            renderer.domElement.style.width = "640px";
            renderer.domElement.style.height = "320px";
            document.body.appendChild(renderer.domElement);

            animate.bind(this, () => {
                material.map.needsUpdate = true;
                composer.render(scene, camera);
            })();
        }

        // https://stackoverflow.com/questions/13360625/three-js-fisheye-effect
        function getDistortionShaderDefinition() {
            return {

                uniforms: {
                    "tDiffuse": { type: "t", value: null },
                    "strength": { type: "f", value: 0 },
                    "height": { type: "f", value: 1 },
                    "aspectRatio": { type: "f", value: 1 },
                    "cylindricalRatio": { type: "f", value: 1 }
                },

                vertexShader: [
                    "uniform float strength;",          // s: 0 = perspective, 1 = stereographic
                    "uniform float height;",            // h: tan(verticalFOVInRadians / 2)
                    "uniform float aspectRatio;",       // a: screenWidth / screenHeight
                    "uniform float cylindricalRatio;",  // c: cylindrical distortion ratio. 1 = spherical

                    "varying vec3 vUV;",                // output to interpolate over screen
                    "varying vec2 vUVDot;",             // output to interpolate over screen

                    "void main() {",
                    "gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));",

                    "float scaledHeight = strength * height;",
                    "float cylAspectRatio = aspectRatio * cylindricalRatio;",
                    "float aspectDiagSq = aspectRatio * aspectRatio + 1.0;",
                    "float diagSq = scaledHeight * scaledHeight * aspectDiagSq;",
                    "vec2 signedUV = (2.0 * uv + vec2(-1.0, -1.0));",

                    "float z = 0.5 * sqrt(diagSq + 1.0) + 0.5;",
                    "float ny = (z - 1.0) / (cylAspectRatio * cylAspectRatio + 1.0);",

                    "vUVDot = sqrt(ny) * vec2(cylAspectRatio, 1.0) * signedUV;",
                    "vUV = vec3(0.5, 0.5, 1.0) * z + vec3(-0.5, -0.5, 0.0);",
                    "vUV.xy += uv;",
                    "}"
                ].join("\n"),

                fragmentShader: [
                    "uniform sampler2D tDiffuse;",      // sampler of rendered scene?s render target
                    "varying vec3 vUV;",                // interpolated vertex output data
                    "varying vec2 vUVDot;",             // interpolated vertex output data

                    "void main() {",
                    "vec3 uv = dot(vUVDot, vUVDot) * vec3(-0.5, -0.5, -1.0) + vUV;",
                    "gl_FragColor = texture2DProj(tDiffuse, uv);",
                    "}"
                ].join("\n")

            };
        }

        function animate(render) {
            requestAnimationFrame(animate.bind(this, render));
            render();
        }

    </script>
</body>

</html>
